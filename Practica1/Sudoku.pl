% RepresentaciÃ³n del Sudoku como una lista de 81 elementos
%Sudoku 1 diabolico Github
sudoku1([
    ., 8, 3, ., 2, ., ., 9, .,
    ., ., ., 8, ., ., 1, ., .,
    ., 2, 9, 3, ., ., ., ., 8,
    ., ., ., ., 9, 8, 7, ., .,
    ., 7, ., ., ., ., ., 6, .,
    ., ., 6, 7, 4, ., ., ., .,
    3, ., ., ., ., 6, 9, 8, .,
    ., ., 2, ., ., 5, ., ., .,
    ., 1, ., ., 3, ., 5, 4, .]).

%Sudoku 1 muy facil
sudoku([
    ., 8, ., 5, 7, 6, 2, ., .,
    ., ., ., 4, ., 2, ., ., .,
    ., ., ., ., 3, 9, 5, 4, 8,
    6, 3, ., 9, ., ., 8, 5, 2,
    ., 9, ., 2, ., ., 3, 7, .,
    8, ., ., ., 5, ., 6, 9, 4,
    2, 5, 7, 6, ., 3, 4, 8, 9,
    3, ., 8, 7, ., ., ., 2, 5,
    ., 4, ., ., ., ., ., ., 6
]).

%Sudoku 2 diabolico Github
sudoku2([
    2, ., ., ., 5, ., ., ., 6,
    ., 1, ., ., ., ., ., 9, .,
    6, ., ., 8, ., 1, ., ., 3,
    ., ., 7, ., 9, ., 6, ., .,
    ., ., ., 7, ., 3, ., ., .,
    9, ., ., ., 8, ., ., ., 2,
    1, ., ., ., ., ., ., ., 5,
    ., 6, ., 9, ., 2, ., 1, .,
    ., ., 3, ., 6, ., 2, ., .]).

%Sudoku 25 muy facil
sudoku3([., ., 7, ., ., 8, ., ., .,
         ., 4, 5, 7, 6, ., ., ., 2,
         6, ., ., ., 4, ., 3, ., 5,
         8, 6, ., 5, ., ., 4, ., .,
         ., ., 3, 8, ., 4, ., 6, .,
         ., 7, 2, 6, 9, ., ., 8, 3,
         ., 5, ., ., ., ., ., 4, 7,
         7, ., ., 4, ., ., ., ., 6,
         ., 3, 4, ., ., 6, 2, ., .]).

%Sudoku 1001 facil
sudoku4([ ., ., 6, ., ., 2, 3, ., 4,
         9, ., 4, 7, 5, ., ., 8, 2,
         ., ., 8, ., ., 6, ., ., 5,
         ., ., 3, ., ., ., ., 4, .,
         2, ., ., 4, ., ., 8, 3, .,
         4, ., 7, 5, ., ., ., ., .,
         ., ., ., 6, ., ., ., ., 8,
         7, ., ., ., 2, ., 4, 5, 3,
         ., ., ., 3, 7, ., ., 6, 9]).

%Sudoku 3 diabolico Github
sudoku5([
    5, 9, ., ., ., ., ., ., 7,
    ., 4, ., ., 1, ., ., 8, 3,
    ., ., 8, ., 3, 4, 9, ., .,
    ., ., 1, 4, ., 2, ., ., .,
    ., 6, 9, ., ., ., 8, 2, .,
    ., ., ., 1, ., 9, 3, ., .,
    ., ., 4, 6, 7, ., 2, ., .,
    9, 8, ., ., 4, ., ., 3, .,
    7, ., ., ., ., ., ., 1, 6
]).

% Sudoku 4 diabolico Github
sudoku6([
    ., ., 6, ., ., ., 2, ., .,
    9, ., ., ., ., ., ., ., 4,
    2, 4, 3, ., ., ., 8, 9, 6,
    ., ., ., 5, 9, 1, ., ., .,
    ., ., 2, ., 8, ., 3, ., .,
    4, ., ., 2, ., 3, ., ., 1,
    3, ., ., ., ., ., ., ., 7,
    ., ., ., 9, ., 7, ., ., .,
    ., 1, ., 4, ., 8, ., 2, .]).

% Sudoku 5 diabolico Github
sudoku7([
    ., ., ., ., ., ., ., ., .,
    5, 6, ., ., ., ., ., 3, 2,
    2, 3, ., ., 4, ., ., 7, 9,
    ., ., ., ., 6, ., ., ., .,
    ., 7, ., 5, ., 1, ., 9, .,
    ., ., ., 7, ., 8, ., ., .,
    ., 5, 3, ., ., ., 9, 2, .,
    ., ., 9, 8, ., 6, 5, ., .,
    7, ., ., ., ., ., ., ., 4 ]).

%Sudoku prueba regla 3
sudoku8([
    ., 9, ., ., 2, 4, ., 7, .,
    ., ., ., ., ., ., ., ., .,
    6, 4, ., 3, ., 7, ., ., .,
    ., 7, ., ., 4, 5, 6, ., 3,
    ., 5, ., ., ., ., ., 2, 7,
    2, ., 6, ., ., ., ., ., .,
    3, ., ., ., 8, ., ., 4, .,
    ., 7, ., 4, 3, ., ., 5, 6,
    4, 2, 5, ., ., ., 8, 3, 9
]).

%Sudoku 985 muy facil
sudoku9([
    ., 7, 2, 4, ., ., ., ., .,
    ., ., 8, ., ., ., ., ., 4,
    ., ., ., 2, ., ., ., ., 9,
    2, ., 9, 7, ., ., ., ., .,
    ., 3, ., 8, 4, ., 9, 6, 2,
    ., 6, 4, 5, ., 2, 3, 8, .,
    5, ., 6, 3, ., 8, ., 4, .,
    3, 4, 7, ., 2, 6, 5, ., 8,
    ., 2, ., ., ., 4, ., ., .]).

%Sudoku 988 muy facil
sudoku10([
    ., 7, ., ., 5, ., 3, ., .,
    ., ., 6, 3, 2, 7, ., 1, .,
    5, ., ., ., 8, 9, 4, 6, .,
    3, ., 8, ., 6, 2, 9, 7, .,
    7, 6, ., 9, 3, ., 8, 4, 5,
    ., ., 5, 7, 4, 8, 2, ., 6,
    ., ., 4, 8, ., ., ., ., 3,
    ., 8, ., 2, 9, ., ., 5, .,
    6, ., ., 4, 7, 5, ., 8, 2]).

%Sudoku 991 muy facil
sudoku11([
    ., 4, ., 6, ., 2, 8, ., 3,
    3, 8, 2, 9, 7, ., ., 4, 5,
    ., ., 6, 8, ., 4, 2, 9, 7,
    4, 2, 5, 3, 6, ., ., ., .,
    ., ., 3, ., ., 7, ., 6, .,
    ., ., ., ., ., ., ., 3, 8,
    5, 7, ., 2, ., ., 3, 8, .,
    6, 3, ., 4, 9, 5, 7, 2, .,
    ., ., 4, 7, 8, ., ., 5, 6 ]).

%Sudoku 1007 muy facil
sudoku12([
    ., ., ., ., 9, 7, 4, 6, .,
    ., 4, ., 1, ., ., ., 9, .,
    ., ., ., ., ., 6, 1, 5, 8,
    ., 6, 4, 2, ., ., 9, 3, .,
    ., ., ., ., 4, ., ., ., .,
    ., 7, ., 6, ., 5, ., 8, .,
    4, 9, ., 3, 8, 1, ., ., 5,
    ., ., 6, ., ., ., ., 1, 9,
    ., ., 2, 5, ., ., 7, ., .]).

%Sudoku 1010 muy facil
sudoku13([
    ., 3, ., ., ., ., 4, 7, .,
    ., ., 4, ., 7, ., ., ., 8,
    8, 7, ., 6, ., 4, ., ., 2,
    ., ., 5, ., ., 8, 2, ., 6,
    3, ., 2, 4, ., ., 7, ., 5,
    ., ., ., ., 2, 7, ., ., 3,
    5, 4, ., 9, 6, ., 3, 8, .,
    ., ., ., ., 4, 3, ., 6, .,
    ., ., ., ., ., ., ., 2, .]).

%Sudoku 1217 facil
sudoku14([
    ., ., ., ., 3, ., ., ., 4,
    ., 9, ., 4, ., 6, ., 7, .,
    ., 5, ., ., ., ., 3, 8, .,
    ., ., ., ., 7, 8, ., ., 3,
    3, ., ., ., ., ., 6, 9, .,
    5, 4, ., 6, ., ., ., 2, .,
    7, ., 5, ., 2, 4, ., ., .,
    9, 8, 4, ., 6, 5, 2, ., .,
    ., 2, 6, ., 8, ., ., ., 9]).

%Sudoku 1220 facil
sudoku15([
    ., 8, ., ., ., ., 6, 9, 3,
    2, 6, 9, ., ., ., ., ., 5,
    ., 7, ., 9, 6, ., 2, ., 8,
    ., ., ., 4, ., ., 8, ., 9,
    ., ., 8, 6, ., ., 4, 5, .,
    ., 3, 1, ., ., ., ., ., .,
    3, ., 2, 5, 8, ., ., ., 7,
    ., ., ., ., ., 6, ., 1, .,
    7, 4, 6, ., 3, ., ., ., .]).

%Sudoku 1 medio Repositorio Github
sudoku16([
    ., 2, ., 9, ., ., ., ., .,
    ., 4, 8, ., ., ., ., 3, 1,
    ., ., ., ., 6, 3, ., 2, .,
    ., ., 9, 4, ., 7, ., ., 3,
    ., ., 3, ., 8, ., 2, ., .,
    4, ., ., 1, ., 5, 6, ., .,
    ., 3, ., 5, 7, ., ., ., .,
    2, 5, ., ., ., ., 1, 8, .,
    ., ., ., ., ., 6, ., 5, .]).

%Sudoku 2 medio Repositorio Github
sudoku17([
    1, ., ., 8, ., ., 5, 7, .,
    ., ., ., ., ., 9, 2, 1, .,
    ., 9, ., ., 4, ., ., ., .,
    3, ., ., 9, ., ., ., 5, .,
    ., ., 7, ., ., ., 3, ., .,
    ., 2, ., ., ., 6, ., ., 8,
    ., ., ., ., 2, ., ., 4, .,
    ., 7, 1, 4, ., ., ., ., .,
    ., 6, 4, ., ., 7, ., ., 3]).

%Sudoku 3 medio Repositorio Github
sudoku18([
    ., ., 2, ., ., ., 8, ., .,
    ., ., 5, ., 2, ., 1, ., .,
    4, 6, ., ., ., ., ., 2, 9,
    1, 3, ., ., 6, ., ., 5, 2,
    ., ., 9, ., 8, ., 4, ., .,
    ., ., ., 3, ., 2, ., ., .,
    ., ., 6, ., 7, ., 2, ., .,
    7, ., ., ., ., ., ., ., 8,
    ., 2, ., 5, 1, 9, ., 7, .]).

%Sudoku 4 medio Repositorio Github
sudoku19([
    8, ., 2, 6, ., ., ., ., 9,
    ., ., ., ., 5, 8, ., ., .,
    ., ., 6, ., ., ., 4, ., 1,
    ., 9, ., 4, ., 6, ., ., 5,
    ., 2, ., ., ., ., ., 4, .,
    6, ., ., 2, ., 3, ., 9, .,
    2, ., 5, ., ., ., 9, ., .,
    ., ., ., 9, 7, ., ., ., .,
    1, ., ., ., ., 2, 8, ., 4]).

%Sudoku 5 medio Repositorio Github
sudoku20([
    ., 7, ., ., ., ., 1, 2, .,
    1, ., ., ., ., ., ., 6, 7,
    ., ., ., 2, ., ., ., ., 4,
    2, ., ., ., 4, ., ., 7, .,
    7, 1, ., ., 3, ., ., 4, 9,
    ., 9, ., ., 7, ., ., ., 1,
    3, ., ., ., ., 9, ., ., .,
    9, 5, ., ., ., ., ., ., 6,
    ., 6, 7, ., ., ., ., 8, .]).

%Sudoku 1 dificil Repositorio Github
sudoku21([
    ., 8, ., 2, ., ., 4, ., .,
    5, 7, ., ., ., ., 1, ., .,
    ., ., 2, 3, ., ., ., ., .,
    8, 2, ., ., 9, ., ., ., 5,
    ., ., ., 7, 1, 5, ., ., .,
    7, ., ., ., 2, ., ., 4, 1,
    ., ., ., ., ., 6, 7, ., .,
    ., ., 3, ., ., ., ., 1, 8,
    ., ., 7, ., ., 9, ., 5, .]).

%Sudoku 2 dificil Repositorio Github
sudoku22([
    6, ., ., ., 5, ., ., ., 7,
    ., 3, ., ., ., ., ., ., .,
    ., 8, ., 4, ., 9, 2, ., .,
    ., 1, 5, 3, ., ., ., ., .,
    ., ., 8, ., ., ., 3, ., .,
    ., ., ., ., ., 7, 5, 9, .,
    ., ., 9, 5, ., 1, ., 3, .,
    ., ., ., ., ., ., ., 8, .,
    2, ., ., ., 7, ., ., ., 4]).

%Sudoku 3 dificil Repositorio Github
sudoku23([
    2, 1, ., 9, 5, ., ., ., 4,
    ., 9, ., ., 6, ., ., 3, 7,
    ., ., ., 7, ., ., ., ., .,
    ., ., ., ., ., ., 3, ., 8,
    9, 2, ., ., ., ., ., 1, 5,
    8, ., 5, ., ., ., ., ., .,
    ., ., ., ., ., 2, ., ., .,
    6, 8, ., ., 1, ., ., 4, .,
    1, ., ., ., 4, 7, ., 9, 6]).

%Sudoku 4 dificil Repositorio Github
sudoku24([
    ., 2, 4, ., ., ., 6, 5, .,
    1, ., ., ., ., ., ., ., 7,
    ., ., 8, ., 1, ., 9, ., .,
    ., ., ., ., ., ., ., ., .,
    2, 6, ., ., 9, ., ., 8, 3,
    ., 8, ., 5, ., 1, ., 7, .,
    6, ., ., 9, ., 3, ., ., 8,
    ., ., 2, 8, 5, 4, 7, ., .,
    ., ., ., ., 7, ., ., ., .]).

%Sudoku 5 dificil Repositorio Github
sudoku25([
    ., ., ., ., 5, ., ., ., .,
    ., ., ., 2, ., 6, ., ., .,
    ., 6, 4, ., ., ., 3, 9, .,
    ., 4, 5, ., ., ., 8, 1, .,
    ., ., ., ., 2, ., ., ., .,
    ., ., ., 1, ., 7, ., ., .,
    ., 5, 3, ., ., ., 9, 8, .,
    ., 9, ., 8, ., 4, ., 6, .,
    1, ., ., ., 3, ., ., ., 4]).



indice_filas([1,2,3,10,11,12,19,20,21,4,5,6,13,14,15,22,23,24,7,8,9,16,17,18,25,26,27,28,29,30,37,38,39,46,47,48,31,32,33,40,41,42,49,50,51,34,35,36,43,44,45,52,53,54,55,56,57,64,65,66,73,74,75,58,59,60,67,68,69,76,77,78,61,62,63,70,71,72,79,80,81]).

% Predicado para imprimir el tablero de Sudoku
imprimir_sudoku([]).
imprimir_sudoku(Tablero) :-
    imprimir_fila(Tablero, Resto),
    imprimir_sudoku(Resto).

% Predicado para imprimir una fila del tablero
imprimir_fila(Tablero, Resto) :-
    tomar(9, Tablero, Fila, Resto),
    writeln(Fila).

% Predicado para tomar los primeros N elementos de una lista
tomar(0, L, [], L).
tomar(N, [H|T], [H|R], Resto) :-
    N > 0,
    N1 is N - 1,
    tomar(N1, T, R, Resto).

% -------------------------------
% Predicados Auxiliares
% -------------------------------

% Dividir el tablero en filas (9 elementos cada una).
filas_sudoku([], []).
filas_sudoku(Sudoku, [Fila|Filas]) :-
    tomar(9, Sudoku, Fila, Resto),
    filas_sudoku(Resto, Filas).

% Predicado para saltar N elementos en una lista.
skip(0, L, L).
skip(N, [_|T], Rest) :-
    N > 0,
    N1 is N - 1,
    skip(N1, T, Rest).

% Predicado para extraer una sublista (slicing): desde la posiciÃ³n Start, Count elementos.
slice(List, Start, Count, Slice) :-
    skip(Start, List, Rest),
    tomar(Count, Rest, Slice, _).

% Hechos
numero(1).
numero(2).
numero(3).
numero(4).
numero(5).
numero(6).
numero(7).
numero(8).
numero(9).

% Predicado para verificar si un nÃºmero estÃ¡ en la misma fila
miembro_fila(Sudoku, Index, Num) :-
    Fila is Index // 9,
    Inicio is Fila * 9,
    Fin is Inicio + 8,
    between(Inicio, Fin, I),
    nth0(I, Sudoku, Num).

% Predicado para verificar si un nÃºmero estÃ¡ en la misma columna
miembro_columna(Sudoku, Index, Num) :-
    Columna is Index mod 9,
    between(0, 8, Fila),
    I is Fila * 9 + Columna,
    nth0(I, Sudoku, Num).

% -------------------------------
% Predicado para Verificar el Cuadrante (3x3) por Slicing
% -------------------------------

miembro_cuadro(Sudoku, Index, Num) :-
    % CÃ¡lculo de fila y columna del elemento (0-based)
    Row is Index // 9,
    Col is Index mod 9,
    % Determinar el inicio (cabezera) del bloque 3Ã3
    RowStart is (Row // 3) * 3,
    ColStart is (Col // 3) * 3,
    % Convertir el tablero en una lista de filas
    filas_sudoku(Sudoku, Filas),
    % Extraer las 3 filas que componen el bloque:
    nth0(RowStart, Filas, Fila1),
    Row2 is RowStart + 1,
    nth0(Row2, Filas, Fila2),
    Row3 is RowStart + 2,
    nth0(Row3, Filas, Fila3),
    % Extraer el segmento de cada fila correspondiente al bloque (3 celdas)
    slice(Fila1, ColStart, 3, Seccion1),
    slice(Fila2, ColStart, 3, Seccion2),
    slice(Fila3, ColStart, 3, Seccion3),
    % Unir las secciones en una lista con todas las celdas del cuadrante
    append([Seccion1, Seccion2, Seccion3], Cuadro),
    % Verificar si el nÃºmero ya se encuentra en ese bloque
    member(Num, Cuadro).

% Predicado para verificar si una casilla estÃ¡ vacÃ­a
casilla_vacia(Casilla) :-
    \+ number(Casilla).

% Predicado para obtener las posibilidades para cada casilla vacÃ­a o generar una lista vacÃ­a si la casilla estÃ¡ ocupada
posibilidades_casilla(Sudoku, Index, Posibilidades) :-
    nth0(Index, Sudoku, Casilla),
    (   casilla_vacia(Casilla) -> 
        findall(Num, (numero(Num),
                      \+ miembro_fila(Sudoku, Index, Num),
                      \+ miembro_columna(Sudoku, Index, Num),
                      \+ miembro_cuadro(Sudoku, Index, Num)
                     ), Posibilidades)
    ;   Posibilidades = []
    ).

% Predicado para generar las listas de posibilidades para todas las casillas
generar_posibilidades(Sudoku, Posibilidades) :-
    generar_posibilidades(Sudoku, 0, Posibilidades).

generar_posibilidades(_, 81, []).
generar_posibilidades(Sudoku, Index, [Posibilidades|Resto]) :-
    Index < 81,
    posibilidades_casilla(Sudoku, Index, Posibilidades),
    NextIndex is Index + 1,
    generar_posibilidades(Sudoku, NextIndex, Resto).

% Predicado para imprimir las posibilidades
imprimir_posibilidades([]).
imprimir_posibilidades([P|Ps]) :-
    writeln(P),
    imprimir_posibilidades(Ps).


% REGLA 0 CON CONTADOR


% Se modifica para que cada iteraciÃ³n incremente el contador.
resolver_regla_0(Sudoku, NuevoSudoku, Contador) :-
    generar_posibilidades(Sudoku, Posibilidades),
    writeln("Posibilidades iniciales:"),
    imprimir_sudoku(Posibilidades),
    actualizar_sudoku(Sudoku, Posibilidades, SudokuActualizado),
    writeln("Sudoku actualizado:"),
    imprimir_sudoku(SudokuActualizado),
    (   Sudoku \= SudokuActualizado ->
            resolver_regla_0(SudokuActualizado, NuevoSudoku, ContadorRec),
            Contador is ContadorRec + 1
    ;   NuevoSudoku = Sudoku,
        Contador = 1
    ).

% Predicado para actualizar el Sudoku con las posibilidades y aplicar la Regla 0
actualizar_sudoku([], [], []).
actualizar_sudoku([C|SudokuResto], [P|PosibilidadesResto], [NuevoC|NuevoSudokuResto]) :-
    (   length(P, 1) ->
        [NuevoC] = P  % Si solo hay una posibilidad, actualizar la casilla con ese nÃºmero
    ;   NuevoC = C    % Si no, mantener la casilla original
    ),
    actualizar_sudoku(SudokuResto, PosibilidadesResto, NuevoSudokuResto).

% Predicado para imprimir el sudoku en forma de lista
imprimir_sudoku_lista :-
    sudoku(Tablero),
    writeln(Tablero).

% Predicado para imprimir el sudoku en forma de tablero
imprimir_sudoku_tablero :-
    sudoku(Tablero),
    imprimir_sudoku(Tablero).

% Predicado para generar la lista de posibilidades
generar_lista_posibilidades :-
    sudoku(Tablero),
    generar_posibilidades(Tablero, Posibilidades).

% Predicado para imprimir lista de posibilidades
imprimir_lista_posibilidades :-
    sudoku3(Tablero),
    generar_posibilidades(Tablero, Posibilidades),
    imprimir_posibilidades(Posibilidades).

% Predicado para probar la Regla 0 (ahora imprime tambiÃ©n el contador)
probar_regla_0 :-
    sudoku(Tablero),
    resolver_regla_0(Tablero, NuevoTablero, Contador),
    imprimir_sudoku(NuevoTablero),
    writeln("NÃºmero de iteraciones:"),
    writeln(Contador),
    generar_posibilidades(NuevoTablero, PosibilidadesActualizadas),
    imprimir_sudoku(PosibilidadesActualizadas).



%----------------------REGLA 1------------------------------


%Cosas de la Regla 1


% Reemplazar un elemento en una lista en una posiciÃ³n dada
replace([_|T], 1, X, [X|T]).
replace([H|T], N, X, [H|R]) :- N > 1, N1 is N - 1, replace(T, N1, X, R).

%Desde Aqui es lo que queda hacer
% Obtener los valores correspondientes a los Ã­ndices dados en la lista de valores
obtener_valores_por_indices([], _, []).

obtener_valores_por_indices([I|RestIndices], Lista_Original, [Valor|ValoresRestantes]) :-
    nth1(I, Lista_Original, Valor), % Extrae el valor en la posiciÃ³n I de ListaValores
    obtener_valores_por_indices(RestIndices, Lista_Original, ValoresRestantes). % ContinÃºa con el resto de Ã­ndices
    

% Regla para incrementar el conteo de un nÃºmero si ya estÃ¡ en la lista
incrementar_conteo(H, [H-N|Resto], [H-N1|Resto]) :-
    N1 is N + 1.

% Si el nÃºmero no es el actual, seguimos buscando en la lista
incrementar_conteo(H, [X|Resto], [X|NuevoResto]) :-
    incrementar_conteo(H, Resto, NuevoResto).


% Si el nÃºmero no estÃ¡ en la lista, lo agregamos con un conteo de 1
incrementar_conteo(H, [], [H-1]).

agregar_conteo([], Conteo, Conteo).

agregar_conteo([H|T], ConteoPrevio, ConteoFinal) :-
    incrementar_conteo(H, ConteoPrevio, ConteoActualizado),
    agregar_conteo(T, ConteoActualizado, ConteoFinal).




% Contar la cantidad de veces que aparece cada nÃºmero en todas las listas
contar_ocurrencias([], []).
contar_ocurrencias([Lista|Resto], ConteoTotal) :-
    contar_ocurrencias(Resto, ConteoParcial),
    agregar_conteo(Lista, ConteoParcial, ConteoTotal).



% Filtrar una lista dejando solo los elementos que aparecen una sola vez en todas las listas
filtrar_unicos([], _, []).
filtrar_unicos([H|T], Conteo, [H|Rest]) :-
    member(H-1, Conteo), % Solo dejamos elementos que aparecen exactamente una vez en la lista completa
    filtrar_unicos(T, Conteo, Rest).
filtrar_unicos([_|T], Conteo, Rest) :-
    filtrar_unicos(T, Conteo, Rest).

% Aplicar el filtrado a todas las sublistas
eliminar_repetidos_global([], _, []).
eliminar_repetidos_global([Lista|Resto], Conteo, [ListaFiltrada|RestoFiltrado]) :-
    filtrar_unicos(Lista, Conteo, ListaFiltrada),
    %writeln("Lista Filtrada: "), %writeln(ListaFiltrada),
    eliminar_repetidos_global(Resto, Conteo, RestoFiltrado).

% Predicado principal para limpiar la lista de repetidos globales
eliminar_repetidos(Listas, Resultado) :-
    contar_ocurrencias(Listas, Conteo),
    eliminar_repetidos_global(Listas, Conteo, Resultado).






% Eliminar repetidos dentro de las listas de filas, columnas y cuadrados
eliminar_repetidos_de_las_listas(_,10, _,Def, Lista_Definitiva):-
    Lista_Definitiva = Def.
    
eliminar_repetidos_de_las_listas([Lista|Rest], Indice, Valores, Def, Lista_Definitiva) :-
    % Acceder a los valores de la lista a travÃ©s de los Ã­ndices
   
    obtener_valores_por_indices(Lista, Valores, Valores_Extraidos),

   

   
    eliminar_repetidos(Valores_Extraidos, ListaSinRepetidos),
    
    % Mostrar la lista sin repetidos
    %writeln('Lista sin repetidos:'),
    %writeln(ListaSinRepetidos),

    % Agregar los valores de ListaSinRepetidos a Def
    append(Def, ListaSinRepetidos, DefActualizado),

    % Imprimir la lista de acumulaciÃ³n
    %writeln('Def actualizada:'),
    writeln(DefActualizado),

    %CONTROLCHECKHASTAAQUI
    Nuevo_Indice is Indice + 1,
    % Continuar con las siguientes listas
    eliminar_repetidos_de_las_listas(Rest, Nuevo_Indice, Valores, DefActualizado, Lista_Definitiva).







% FunciÃ³n que actualiza las posibilidades de acuerdo a los valores Ãºnicos
actualizar_posibilidades_con_unicos(Posibilidades, 82,_,_,Posibilidades_Fin) :-
    % Recorrer todas las casillas del Sudoku (de 1 a 81)
    Posibilidades_Fin=Posibilidades,
    writeln("Posibilidades_Fin"),
    imprimir_sudoku(Posibilidades_Fin).

% Caso recursivo: procesar una casilla y actualizarla si corresponde
actualizar_posibilidades_con_unicos(Posibilidades, Indice, Indice_Guia, Unicos, Posibilidades_Fin) :-
    % Extraer el valor de las posibles posibilidades en el Ã­ndice actual
    nth1(Indice, Posibilidades, ListaPosibilidades),
    %writeln("ListaPosibilidades"), %writeln(ListaPosibilidades),
    % Comprobar si hay un valor Ãºnico en FilaUnicos, ColumnaUnicos o CuadradoUnicos
    (   nth1(Indice, Unicos, ValorUnicos),
        ValorUnicos \= [] ->( % Si la lista no estÃ¡ vacÃ­a
            length(ValorUnicos, 1) ->(
                ValorUnicos = [X]  % Solo si tiene exactamente un elemento y no estÃ¡ vacÃ­a
                ->  Reemplazo = [X],
                writeln("ValorUnicos"),
                writeln(ValorUnicos),
                nth1(Indice,Indice_Guia,Valor_indice_en_posibilidades),
                writeln("Indice"),
                writeln(Valor_indice_en_posibilidades),
                % Reemplazar el valor en la lista de Posibilidades
                replace(Posibilidades, Valor_indice_en_posibilidades, Reemplazo, NuevaPosibilidadesParcial),
                writeln("Posibilidades Parciales"),
                imprimir_sudoku(NuevaPosibilidadesParcial),
                % Llamada recursiva para procesar el siguiente Ã­ndice
                IndiceSiguiente is Indice + 1,
                actualizar_posibilidades_con_unicos(NuevaPosibilidadesParcial,IndiceSiguiente,Indice_Guia  ,Unicos,Posibilidades_Fin)
            )      
            ;
            IndiceSiguiente is Indice + 1,
            actualizar_posibilidades_con_unicos(Posibilidades,IndiceSiguiente, Indice_Guia ,Unicos,Posibilidades_Fin)

        )
    ;
        % Llamada recursiva para procesar el siguiente Ã­ndice
        %Reemplazo = ListaPosibilidades,
        %nth1(Indice,Indice_Guia,Valor_indice_en_posibilidades),
        %replace(Posibilidades, Valor_indice_en_posibilidades, Reemplazo, NuevaPosibilidadesParcial),
        IndiceSiguiente is Indice + 1,
        actualizar_posibilidades_con_unicos(Posibilidades,IndiceSiguiente, Indice_Guia ,Unicos,Posibilidades_Fin)
    ).








% FunciÃ³n principal para iniciar la comparaciÃ³n
verificar_repetidos(Filas, Columnas, Cuadrados, Valores, FilaDef, ColumnaDef, Cuadrados_Def) :-
    % Definir los Ã­ndices
    Indice_Cuadrado=[[1,2,3,10,11,12,19,20,21],[4,5,6,13,14,15,22,23,24],[7,8,9,16,17,18,25,26,27],[28,29,30,37,38,39,46,47,48],[31,32,33,40,41,42,49,50,51],[34,35,36,43,44,45,52,53,54],[55,56,57,64,65,66,73,74,75],[58,59,60,67,68,69,76,77,78],[61,62,63,70,71,72,79,80,81]],
    Indice_Columnas=[[1,10,19,28,37,46,55,64,73],[2,11,20,29,38,47,56,65,74],[3,12,21,30,39,48,57,66,75],[4,13,22,31,40,49,58,67,76],[5,14,23,32,41,50,59,68,77],[6,15,24,33,42,51,60,69,78],[7,16,25,34,43,52,61,70,79],[8,17,26,35,44,53,62,71,80],[9,18,27,36,45,54,63,72,81]],
    Indice_Filas=[[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,27],[28,29,30,31,32,33,34,35,36],[37,38,39,40,41,42,43,44,45],[46,47,48,49,50,51,52,53,54],[55,56,57,58,59,60,61,62,63],[64,65,66,67,68,69,70,71,72],[73,74,75,76,77,78,79,80,81]],

    % Eliminar repetidos dentro de cada lista de filas, columnas y cuadrados

    eliminar_repetidos_de_las_listas(Indice_Filas,1, Valores, Filas, FilaDef),

    eliminar_repetidos_de_las_listas(Indice_Columnas, 1,Valores, Columnas, ColumnaDef),

    eliminar_repetidos_de_las_listas(Indice_Cuadrado, 1, Valores, Cuadrados, Cuadrados_Def).
    



% Caso base: cuando hemos procesado todas las casillas
aplicar_regla_1(Posibilidades, FilaUnicos, ColumnaUnicos, CuadradoUnicos,FilaDef, ColumnaDef, Cuadrados_Def, NuevaPosibilidades) :-
    verificar_repetidos(FilaUnicos, ColumnaUnicos, CuadradoUnicos, Posibilidades, FilaDef, ColumnaDef, Cuadrados_Def),

    Posibilidades_Originales=Posibilidades,

    Indice_Cuadrado=[1,2,3,10,11,12,19,20,21,4,5,6,13,14,15,22,23,24,7,8,9,16,17,18,25,26,27,28,29,30,37,38,39,46,47,48,31,32,33,40,41,42,49,50,51,34,35,36,43,44,45,52,53,54,55,56,57,64,65,66,73,74,75,58,59,60,67,68,69,76,77,78,61,62,63,70,71,72,79,80,81],
    Indice_Columnas=[1,10,19,28,37,46,55,64,73,2,11,20,29,38,47,56,65,74,3,12,21,30,39,48,57,66,75,4,13,22,31,40,49,58,67,76,5,14,23,32,41,50,59,68,77,6,15,24,33,42,51,60,69,78,7,16,25,34,43,52,61,70,79,8,17,26,35,44,53,62,71,80,9,18,27,36,45,54,63,72,81],
    Indice_Filas=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],

    actualizar_posibilidades_con_unicos(Posibilidades, 1,Indice_Filas,FilaDef, Temp1),
    writeln("Filas"),
    (Posibilidades_Originales\==Temp1
    -> NuevaPosibilidades=Temp1
    ;
        Temp1_Original=Temp1,
        writeln("Columnas"),
        actualizar_posibilidades_con_unicos(Temp1, 1,Indice_Columnas ,ColumnaDef, Temp2),
        (Temp1_Original\==Temp2
        -> NuevaPosibilidades=Temp2
        ;
        writeln("Cuadrado"),
        actualizar_posibilidades_con_unicos(Temp2, 1,Indice_Cuadrado, Cuadrados_Def, NuevaPosibilidades)
        )

    ).



% Predicado para aplicar la Regla 0 y actualizar el Sudoku
%No confundir este con resolver_regla_0_y_1. AquÃ­ estamos haciendo que se iteren de manera continua la regla 1 y 0 en vez de estar solo haciendo la 1 una vez y la 0 multiples hasta que no haya cambios
resolver_reglas_0_y_1(Sudoku, SudokuOut, ContadorR0, ContadorR1) :-
    % 1) Aplicas la Regla 0 (iterativa) al Sudoku
    resolver_regla_0(Sudoku, SudokuTemp, ContadorR0),
    
    % 2) Generas posibilidades del resultado
    generar_posibilidades(SudokuTemp, PosTemp),
    
    % 3) Aplicas la Regla 1 (iterativa) a esas posibilidades
    resolver_regla_1(PosTemp, PosTemp2, ContadorR1),
    
    % 4) Con esas posibilidades finales, vuelves a actualizar el Sudoku
    actualizar_sudoku(SudokuTemp, PosTemp2, SudokuOut).

% Predicado para aplicar la Regla 0 una vez
aplicar_regla_0_1(Sudoku, Posibilidades, NuevoSudoku, Contador) :-
    actualizar_sudoku(Sudoku, Posibilidades, SudokuActualizado),
    writeln("Sudoku Actualizado"),
    imprimir_sudoku(SudokuActualizado),
    (   Sudoku \= SudokuActualizado
    ->  % Se hace la recursiÃ³n sobre el Sudoku actualizado
        aplicar_regla_0_1(SudokuActualizado, Posibilidades, NuevoSudoku, ContadorRec),
        Contador is ContadorRec + 1
    ;   NuevoSudoku = Sudoku,
        Contador = 1
    ).

% Predicado para aplicar la Regla 1 con contador (iterativo)
resolver_regla_1(Posibilidades, NuevaPosibilidades, Contador) :-
    aplicar_regla_1(Posibilidades, FilaUnicos, ColumnaUnicos, CuadradoUnicos, 
                      FilaDef, ColumnaDef, Cuadrados_Def, TempPosibilidades),
    (   Posibilidades \== TempPosibilidades ->
            resolver_regla_1(TempPosibilidades, NuevaPosibilidades, ContadorRec),
            Contador is ContadorRec + 1
    ;   NuevaPosibilidades = Posibilidades,
        Contador = 1
    ).


probar_regla_1 :-
    sudoku(Tablero),
    generar_posibilidades(Tablero, Posibilidades),
    resolver_regla_1(Posibilidades, NuevaPosibilidades, Contador),
    writeln("NÃºmero de iteraciones en Regla 1:"),
    writeln(Contador),
    imprimir_sudoku(NuevaPosibilidades).


iterar_reglas_0_y_1(Sudoku, NuevoSudoku, ContadorTotalR1) :-
    resolver_reglas_0_y_1(Sudoku, SudokuIntermedio, C0, C1),
    (   Sudoku \= SudokuIntermedio
    ->  iterar_reglas_0_y_1(SudokuIntermedio, NuevoSudoku, ContadorRec),
        ContadorTotalR1 is C0 + C1 + ContadorRec
    ;   NuevoSudoku = Sudoku,
        ContadorTotalR1 is 0
    ).

%----------------------------------------------------------
% REGLA 2 (versiÃ³n original, pero necesitamos "resolver_regla_2")
%----------------------------------------------------------

% Predicado para obtener las posibilidades de una fila
obtener_posibilidades_fila(Posibilidades, Fila, PosibilidadesFila) :-
    % Calcula el rango de Ã­ndices correspondientes a la fila
    Inicio is (Fila - 1) * 9 + 1,
    Fin is Fila * 9,
    % Utiliza findall para recopilar las posibilidades de cada celda en la fila
    findall(Posibilidad,
            ( between(Inicio, Fin, Index),
              nth1(Index, Posibilidades, Posibilidad)
            ),
            PosibilidadesFila).

% Predicado para obtener las posibilidades de una columna
obtener_posibilidades_columna(Posibilidades, Columna, PosibilidadesColumna) :-
    % Utiliza findall para recopilar las posibilidades de cada celda en la columna
    findall(Posibilidad,
            ( between(0, 8, I),
              Index is Columna + I * 9,
              nth1(Index, Posibilidades, Posibilidad)
            ),
            PosibilidadesColumna).

% Predicado para obtener las posibilidades de un cuadro
obtener_posibilidades_cuadro(Posibilidades, Cuadro, PosibilidadesCuadro) :-
    % Calcula los Ã­ndices de las celdas en el cuadro
    CuadroFila is (Cuadro - 1) // 3 * 3,
    CuadroColumna is (Cuadro - 1) mod 3 * 3,
    % Utiliza findall para recopilar las posibilidades de cada celda en el cuadro
    findall(Posibilidad,
            ( between(0, 2, I),
              between(0, 2, J),
              Index is (CuadroFila + I) * 9 + CuadroColumna + J + 1,
              nth1(Index, Posibilidades, Posibilidad)
            ),
            PosibilidadesCuadro).

% Predicado que realiza UNA SOLA PASADA de la Regla 2 sobre todas filas, columnas y cuadros
aplicar_regla_2(Posibilidades, NuevaPosibilidades) :-
    % Aplicar la Regla 2 a filas
    aplicar_regla_2_a_todas_filas(Posibilidades, Temp1),
    % Aplicar la Regla 2 a columnas
    aplicar_regla_2_a_todas_columnas(Temp1, Temp2),
    % Aplicar la Regla 2 a cuadros
    aplicar_regla_2_a_todos_cuadros(Temp2, NuevaPosibilidades).

%----------------------------------------------------------
% REGLA 2 CON CONTADOR (iterativa hasta que no cambie)
%----------------------------------------------------------
%
% Este predicado itera aplicar_regla_2/2 hasta que las posibilidades
% dejen de cambiar, y en cada cambio incrementa el contador.

resolver_regla_2(Posibilidades, NuevaPosibilidades, Contador) :-
    aplicar_regla_2(Posibilidades, TempPosibilidades),
    (   % Si hay cambios, recursiÃ³n e incremento de contador
        Posibilidades \== TempPosibilidades
    ->  resolver_regla_2(TempPosibilidades, NuevaPosibilidades, ContadorRec),
        Contador is ContadorRec + 1
    ;   % Si NO hay cambios, fin de la iteraciÃ³n
        NuevaPosibilidades = TempPosibilidades,
        Contador = 1
    ).

%----------------------------------------------------------
% Auxiliares para aplicar_regla_2
%----------------------------------------------------------

% Predicado para aplicar la Regla 2 a todas las filas
aplicar_regla_2_a_todas_filas(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_2_a_todas_filas(Posibilidades, 1, NuevaPosibilidades).

% Caso base: cuando se han procesado todas las filas
aplicar_regla_2_a_todas_filas(Posibilidades, 10, Posibilidades) :- !.
% Caso recursivo: procesar una fila y continuar con la siguiente
aplicar_regla_2_a_todas_filas(Posibilidades, Fila, NuevaPosibilidades) :-
    % Obtener las posibilidades de la fila actual
    obtener_posibilidades_fila(Posibilidades, Fila, PosibilidadesFila),
    % Encontrar pares Ãºnicos en la fila
    encontrar_pares_unicos(PosibilidadesFila, ParesUnicos),
    % Eliminar dichos pares en la fila
    eliminar_pares_de_fila(Posibilidades, Fila, ParesUnicos, TempPosibilidades),
    % Siguiente fila
    FilaSiguiente is Fila + 1,
    aplicar_regla_2_a_todas_filas(TempPosibilidades, FilaSiguiente, NuevaPosibilidades).

% Predicado para aplicar la Regla 2 a todas las columnas
aplicar_regla_2_a_todas_columnas(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_2_a_todas_columnas(Posibilidades, 1, NuevaPosibilidades).

% Caso base: cuando se han procesado todas las columnas
aplicar_regla_2_a_todas_columnas(Posibilidades, 10, Posibilidades) :- !.
% Caso recursivo: procesar una columna y continuar
aplicar_regla_2_a_todas_columnas(Posibilidades, Columna, NuevaPosibilidades) :-
    obtener_posibilidades_columna(Posibilidades, Columna, PosibilidadesColumna),
    encontrar_pares_unicos(PosibilidadesColumna, ParesUnicos),
    eliminar_pares_de_columna(Posibilidades, Columna, ParesUnicos, TempPosibilidades),
    ColumnaSiguiente is Columna + 1,
    aplicar_regla_2_a_todas_columnas(TempPosibilidades, ColumnaSiguiente, NuevaPosibilidades).

% Predicado para aplicar la Regla 2 a todos los cuadros
aplicar_regla_2_a_todos_cuadros(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_2_a_todos_cuadros(Posibilidades, 1, NuevaPosibilidades).

% Caso base: cuando se han procesado todos los cuadros
aplicar_regla_2_a_todos_cuadros(Posibilidades, 10, Posibilidades) :- !.
% Caso recursivo: procesar un cuadro y continuar
aplicar_regla_2_a_todos_cuadros(Posibilidades, Cuadro, NuevaPosibilidades) :-
    obtener_posibilidades_cuadro(Posibilidades, Cuadro, PosibilidadesCuadro),
    encontrar_pares_unicos(PosibilidadesCuadro, ParesUnicos),
    eliminar_pares_de_cuadro(Posibilidades, Cuadro, ParesUnicos, TempPosibilidades),
    CuadroSiguiente is Cuadro + 1,
    aplicar_regla_2_a_todos_cuadros(TempPosibilidades, CuadroSiguiente, NuevaPosibilidades).

%----------------------------------------------------------
% Predicados para encontrar y eliminar pares
%----------------------------------------------------------

% Predicado para encontrar pares de nÃºmeros que aparecen solo en dos casillas
encontrar_pares_unicos(PosibilidadesGrupo, ParesUnicos) :-
    findall(
        [Num1, Num2],
        ( member(Posibilidad, PosibilidadesGrupo),
          length(Posibilidad, 2),
          [Num1, Num2] = Posibilidad,
          contar_ocurrencias(PosibilidadesGrupo, [Num1, Num2], 2)
        ),
        ParesUnicos
    ).

% Cuenta ocurrencias de un par exacto en la lista
contar_ocurrencias([], _, 0).
contar_ocurrencias([H|T], H, N) :-
    contar_ocurrencias(T, H, N1),
    N is N1 + 1.
contar_ocurrencias([_|T], H, N) :-
    contar_ocurrencias(T, H, N).

% Eliminar pares de una fila
eliminar_pares_de_fila(Posibilidades, Fila, ParesUnicos, NuevaPosibilidades) :-
    Inicio is (Fila - 1) * 9 + 1,
    Fin is Fila * 9,
    findall(Index, between(Inicio, Fin, Index), Indices),
    eliminar_pares_de_indices(Posibilidades, Indices, ParesUnicos, NuevaPosibilidades).

% Eliminar pares de una columna
eliminar_pares_de_columna(Posibilidades, Columna, ParesUnicos, NuevaPosibilidades) :-
    findall(Index,
            ( between(0, 8, I),
              Index is Columna + I * 9
            ),
            Indices),
    eliminar_pares_de_indices(Posibilidades, Indices, ParesUnicos, NuevaPosibilidades).

% Eliminar pares de un cuadro
eliminar_pares_de_cuadro(Posibilidades, Cuadro, ParesUnicos, NuevaPosibilidades) :-
    CuadroFila is (Cuadro - 1) // 3 * 3,
    CuadroColumna is (Cuadro - 1) mod 3 * 3,
    findall(Index,
            ( between(0, 2, I),
              between(0, 2, J),
              Index is (CuadroFila + I) * 9 + CuadroColumna + J + 1
            ),
            Indices),
    eliminar_pares_de_indices(Posibilidades, Indices, ParesUnicos, NuevaPosibilidades).

% Eliminar pares de una lista de Ã­ndices
eliminar_pares_de_indices(Posibilidades, [], _, Posibilidades).
eliminar_pares_de_indices(Posibilidades, [Indice|RestoIndices], ParesUnicos, NuevaPosibilidades) :-
    nth1(Indice, Posibilidades, PosibilidadActual),
    eliminar_pares_de_posibilidad(PosibilidadActual, ParesUnicos, NuevaPosibilidad),
    replace(Posibilidades, Indice, NuevaPosibilidad, TempPosibilidades),
    eliminar_pares_de_indices(TempPosibilidades, RestoIndices, ParesUnicos, NuevaPosibilidades).

% Eliminar pares de una posibilidad concreta
eliminar_pares_de_posibilidad(Posibilidad, [], Posibilidad).
eliminar_pares_de_posibilidad(Posibilidad, [[Num1, Num2]|RestoPares], NuevaPosibilidad) :-
    (   length(Posibilidad, 2),
        member(Num1, Posibilidad),
        member(Num2, Posibilidad)
    ->  % Es uno de los pares exactos: NO lo tocamos
        eliminar_pares_de_posibilidad(Posibilidad, RestoPares, NuevaPosibilidad)
    ;   % En caso contrario, sacamos Num1 y Num2 (si estuvieran)
        eliminar_numero(Posibilidad, Num1, TempPos1),
        eliminar_numero(TempPos1, Num2, TempPos2),
        eliminar_pares_de_posibilidad(TempPos2, RestoPares, NuevaPosibilidad)
    ).

% Eliminar un nÃºmero de una lista
eliminar_numero([], _, []).
eliminar_numero([H|T], H, T).
eliminar_numero([H|T], Num, [H|R]) :-
    eliminar_numero(T, Num, R).

%----------------------------------------------------------
% Ejemplo de "probar_regla_2" con contador
%----------------------------------------------------------
%
% Ahora usamos resolver_regla_2/3 en vez de aplicar_regla_2/2
% para ver cuÃ¡ntas iteraciones se realizaron efectivamente.

probar_regla_2 :-
    sudoku1(Tablero),
    generar_posibilidades(Tablero, Posibilidades),
    resolver_regla_2(Posibilidades, NuevaPosibilidades, Contador),
    writeln("Posibilidades despues de aplicar la Regla 2:"),
    imprimir_sudoku(NuevaPosibilidades),
    writeln("Numero de iteraciones de la Regla 2:"),
    writeln(Contador).



resolver_reglas_0_y_2(Sudoku, NuevoSudoku, ContadorThisPass) :-
    % 1. Generar posibilidades del Sudoku
    generar_posibilidades(Sudoku, Posibilidades),
    
    % 2. Aplicar Regla 2 iterativamente (retorna ContadorR2)
    resolver_regla_2(Posibilidades, PosibilidadesRegla2, ContadorR2),
    writeln("Posibilidades despues de aplicar la Regla 2:"),
    imprimir_sudoku(PosibilidadesRegla2),
    
    % 3. Aplicar Regla 0 iterativamente al Sudoku (retorna ContadorR0)
    resolver_regla_0(Sudoku, SudokuResultante, ContadorR0),
    writeln("Sudoku despues de aplicar la Regla 0:"),
    imprimir_sudoku(SudokuResultante),

    % 4. Devolvemos el Sudoku resultante y la suma de iteraciones
    NuevoSudoku = SudokuResultante,
    ContadorThisPass is ContadorR0 + ContadorR2.


iterar_reglas_0_y_2(Sudoku, NuevoSudoku, ContadorTotal) :-
    resolver_reglas_0_y_2(Sudoku, SudokuIntermedio, ContadorEstaPasada),
    (   Sudoku \= SudokuIntermedio
    ->  % Si cambiÃ³, volvemos a iterar
        iterar_reglas_0_y_2(SudokuIntermedio, NuevoSudoku, ContadorRec),
        ContadorTotal is ContadorEstaPasada + ContadorRec
    ;   % Si no cambiÃ³, paramos
        NuevoSudoku = Sudoku,
        ContadorTotal is 0
    ).


probar_reglas_0_y_2 :-
    sudoku4(Tablero),
    writeln("Sudoku inicial:"),
    imprimir_sudoku(Tablero),
    iterar_reglas_0_y_2(Tablero, NuevoTablero, ContadorTotal),
    
    writeln("Sudoku despues de aplicar Reglas 0 y 2:"),
    imprimir_sudoku(NuevoTablero),
    format('Numero total de iteraciones (Regla 0 + Regla 2): ~w~n', [ContadorTotal]),

    generar_posibilidades(NuevoTablero, Posibilidades),
    imprimir_sudoku(Posibilidades).


%----------------------------------------------------------
% Reglas 0, 1 y 2 
%----------------------------------------------------------


resolver_reglas_0_y_1_y_2(Sudoku, NuevoSudoku, ContadorThisPass) :-
    % 1. Generar posibilidades
    generar_posibilidades(Sudoku, Posibilidades),

    % 2. Aplicar Regla 2 (iterativa)
    resolver_regla_2(Posibilidades, PosRegla2, ContadorR2),
    writeln("Posibilidades despues de aplicar la Regla 2:"),
    imprimir_sudoku(PosRegla2),

    % 3. Aplicar Regla 1 (iterativa) sobre esas posibilidades
    resolver_regla_1(PosRegla2, PosRegla1, ContadorR1),
    writeln("Posibilidades despues de aplicar la Regla 1:"),
    imprimir_sudoku(PosRegla1),

    % 4. Aplicar Regla 0 (iterativa) en el Sudoku usando PosRegla1
    resolver_regla_0(Sudoku, SudokuResultante, ContadorR0),
    writeln("Sudoku despues de aplicar la Regla 0:"),
    imprimir_sudoku(SudokuResultante),

    % 5. Devolvemos el Sudoku final y la suma
    NuevoSudoku = SudokuResultante,
    ContadorThisPass is ContadorR0 + ContadorR1 + ContadorR2.


iterar_reglas_0_y_1_y_2(Sudoku, NuevoSudoku, ContadorTotal) :-
    resolver_reglas_0_y_1_y_2(Sudoku, SudokuIntermedio, ContadorEstaPasada),
    writeln("Sudoku Intermedio:"),
    imprimir_sudoku(SudokuIntermedio),
    writeln("Fin iteraciÃ³n"),

    (   Sudoku \= SudokuIntermedio
    ->  writeln("Inicio Nueva Iteracion"),
        iterar_reglas_0_y_1_y_2(SudokuIntermedio, NuevoSudoku, ContadorRec),
        ContadorTotal is ContadorEstaPasada + ContadorRec
    ;   NuevoSudoku = Sudoku,
        ContadorTotal is 0
    ).

probar_reglas_0_y_1_y_2 :-
    sudoku4(Tablero),
    writeln("Sudoku inicial:"),
    imprimir_sudoku(Tablero),
    iterar_reglas_0_y_1_y_2(Tablero, NuevoTablero, ContadorTotal),
    writeln("Sudoku despues de aplicar Reglas 0, 1 y 2:"),
    imprimir_sudoku(NuevoTablero),
    format('Numero total de iteraciones (Regla 0 + Regla 1 + Regla 2): ~w~n', [ContadorTotal]),
    generar_posibilidades(NuevoTablero, Posibilidades),
    imprimir_sudoku(Posibilidades).
   %----------------------------------------------------------
% REGLA 3 (versiÃ³n original)
%----------------------------------------------------------

% Encontrar trÃ­os de nÃºmeros que aparecen solo en tres casillas
encontrar_trios_unicos(PosibilidadesGrupo, TriosUnicos) :-
    findall([Num1, Num2, Num3],
        ( member(Posibilidad, PosibilidadesGrupo),
          length(Posibilidad, 3),
          [Num1, Num2, Num3] = Posibilidad,
          contar_ocurrencias(PosibilidadesGrupo, [Num1, Num2, Num3], 3)
        ),
        TriosUnicos
    ).

% Eliminar trÃ­os de una fila
eliminar_trios_de_fila(Posibilidades, Fila, TriosUnicos, NuevaPosibilidades) :-
    Inicio is (Fila - 1) * 9 + 1,
    Fin is Fila * 9,
    findall(Index, between(Inicio, Fin, Index), Indices),
    eliminar_trios_de_indices(Posibilidades, Indices, TriosUnicos, NuevaPosibilidades).

% Eliminar trÃ­os de una columna
eliminar_trios_de_columna(Posibilidades, Columna, TriosUnicos, NuevaPosibilidades) :-
    findall(Index,
            (between(0, 8, I),
             Index is Columna + I * 9
            ),
            Indices
           ),
    eliminar_trios_de_indices(Posibilidades, Indices, TriosUnicos, NuevaPosibilidades).

% Eliminar trÃ­os de un cuadro
eliminar_trios_de_cuadro(Posibilidades, Cuadro, TriosUnicos, NuevaPosibilidades) :-
    CuadroFila is (Cuadro - 1) // 3 * 3,
    CuadroColumna is (Cuadro - 1) mod 3 * 3,
    findall(Index,
        ( between(0, 2, I),
          between(0, 2, J),
          Index is (CuadroFila + I) * 9 + CuadroColumna + J + 1
        ),
        Indices
    ),
    eliminar_trios_de_indices(Posibilidades, Indices, TriosUnicos, NuevaPosibilidades).

% Eliminar trÃ­os de una lista de Ã­ndices
eliminar_trios_de_indices(Posibilidades, [], _, Posibilidades).
eliminar_trios_de_indices(Posibilidades, [Indice|RestoIndices], TriosUnicos, NuevaPosibilidades) :-
    nth1(Indice, Posibilidades, PosActual),
    eliminar_trios_de_posibilidad(PosActual, TriosUnicos, NuevaPos),
    replace(Posibilidades, Indice, NuevaPos, TempPos),
    eliminar_trios_de_indices(TempPos, RestoIndices, TriosUnicos, NuevaPosibilidades).

% Eliminar trÃ­os de una sola posibilidad
eliminar_trios_de_posibilidad(Posibilidad, [], Posibilidad).
eliminar_trios_de_posibilidad(Posibilidad, [[Num1, Num2, Num3]|RestoTrios], NuevaPosibilidad) :-
    (   length(Posibilidad, 3),
        member(Num1, Posibilidad),
        member(Num2, Posibilidad),
        member(Num3, Posibilidad)
    ->  % Es uno de los trÃ­os exactos: NO lo tocamos
        eliminar_trios_de_posibilidad(Posibilidad, RestoTrios, NuevaPosibilidad)
    ;   % En caso contrario, sacamos Num1, Num2 y Num3 (si estuvieran)
        eliminar_numero(Posibilidad, Num1, TempPos1),
        eliminar_numero(TempPos1, Num2, TempPos2),
        eliminar_numero(TempPos2, Num3, TempPos3),
        eliminar_trios_de_posibilidad(TempPos3, RestoTrios, NuevaPosibilidad)
    ).

% Predicado base que hace UNA PASADA de la Regla 3 en filas, columnas, cuadros
aplicar_regla_3(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_3_a_todas_filas(Posibilidades, Temp1),
    aplicar_regla_3_a_todas_columnas(Temp1, Temp2),
    aplicar_regla_3_a_todos_cuadros(Temp2, NuevaPosibilidades).

%----------------------------------------------------------
% REGLA 3 CON CONTADOR (iterativa)
%----------------------------------------------------------
%
% Este predicado itera aplicar_regla_3/2 hasta que no haya mas cambios.
% Cada vez que se produce un cambio, incrementamos el contador.

resolver_regla_3(Posibilidades, NuevaPosibilidades, Contador) :-
    aplicar_regla_3(Posibilidades, TempPosibilidades),
    (   Posibilidades \== TempPosibilidades
    ->  resolver_regla_3(TempPosibilidades, NuevaPosibilidades, C1),
        Contador is C1 + 1
    ;   NuevaPosibilidades = TempPosibilidades,
        Contador = 1
    ).

%----------------------------------------------------------
% Auxiliares para aplicar la Regla 3
%----------------------------------------------------------

% Caso base: filas, columnas y cuadros van de 1 a 9, asÃ­ que ajustamos:
aplicar_regla_3_a_todas_filas(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_3_a_todas_filas(Posibilidades, 1, NuevaPosibilidades).

aplicar_regla_3_a_todas_filas(Posibilidades, 10, Posibilidades) :- !.
aplicar_regla_3_a_todas_filas(Posibilidades, Fila, NuevaPosibilidades) :-
    obtener_posibilidades_fila(Posibilidades, Fila, PosFila),
    encontrar_trios_unicos(PosFila, TriosUnicos),
    eliminar_trios_de_fila(Posibilidades, Fila, TriosUnicos, TempPos),
    FilaSiguiente is Fila + 1,
    aplicar_regla_3_a_todas_filas(TempPos, FilaSiguiente, NuevaPosibilidades).

aplicar_regla_3_a_todas_columnas(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_3_a_todas_columnas(Posibilidades, 1, NuevaPosibilidades).

aplicar_regla_3_a_todas_columnas(Posibilidades, 10, Posibilidades) :- !.
aplicar_regla_3_a_todas_columnas(Posibilidades, Columna, NuevaPosibilidades) :-
    obtener_posibilidades_columna(Posibilidades, Columna, PosCol),
    encontrar_trios_unicos(PosCol, TriosUnicos),
    eliminar_trios_de_columna(Posibilidades, Columna, TriosUnicos, TempPos),
    ColumnaSiguiente is Columna + 1,
    aplicar_regla_3_a_todas_columnas(TempPos, ColumnaSiguiente, NuevaPosibilidades).

aplicar_regla_3_a_todos_cuadros(Posibilidades, NuevaPosibilidades) :-
    aplicar_regla_3_a_todos_cuadros(Posibilidades, 1, NuevaPosibilidades).

aplicar_regla_3_a_todos_cuadros(Posibilidades, 10, Posibilidades) :- !.
aplicar_regla_3_a_todos_cuadros(Posibilidades, Cuadro, NuevaPosibilidades) :-
    obtener_posibilidades_cuadro(Posibilidades, Cuadro, PosCuadro),
    encontrar_trios_unicos(PosCuadro, TriosUnicos),
    eliminar_trios_de_cuadro(Posibilidades, Cuadro, TriosUnicos, TempPos),
    CuadroSiguiente is Cuadro + 1,
    aplicar_regla_3_a_todos_cuadros(TempPos, CuadroSiguiente, NuevaPosibilidades).

%----------------------------------------------------------
% Ejemplo de "probar_regla_3" con contador
%----------------------------------------------------------

probar_regla_3 :-
    sudoku1(Tablero),
    generar_posibilidades(Tablero, Posibilidades),
    imprimir_sudoku(Posibilidades),

    % Ahora llamamos a resolver_regla_3/3 para obtener el contador:
    resolver_regla_3(Posibilidades, NuevaPosibilidades, ContadorR3),

    writeln("Posibilidades despues de aplicar la Regla 3:"),
    imprimir_sudoku(NuevaPosibilidades),
    writeln("Numero de iteraciones de la Regla 3:"),
    writeln(ContadorR3).


%----------------------------------------------------------
% Reglas 0 y 3 con contador
%----------------------------------------------------------

% Asume que ya tienes:
%   resolver_regla_0(Sudoku, SudokuNuevo, Contador0)

% Aplica primero la Regla 3 sobre las posibilidades (iterativamente),
% luego la Reglaâ¯0 en el sudoku (iterativamente). Puedes mostrar
% o no el contador de la Reglaâ¯3.

resolver_reglas_0_y_3(Sudoku, NuevoSudoku, ContadorThisPass) :-
    % (1) Generar posibilidades actuales
    generar_posibilidades(Sudoku, Posibilidades),

    % (2) Regla 3 iterativa â ContadorR3
    resolver_regla_3(Posibilidades, PosRegla3, ContadorR3),
    writeln("Posibilidades despues de aplicar la Regla 3:"),
    imprimir_sudoku(PosRegla3),

    % (3) Regla 0 iterativa en el Sudoku â ContadorR0
    resolver_regla_0(Sudoku, SudokuRes, ContadorR0),
    writeln("Sudoku despues de aplicar la Regla 0:"),
    imprimir_sudoku(SudokuRes),

    % (4) Devolver Sudoku resultante y suma de contadores
    NuevoSudoku = SudokuRes,
    ContadorThisPass is ContadorR3 + ContadorR0.

% IteraciÃ³n de Reglas 0 y 3 hasta que no haya cambios en el Sudoku,
% acumulando la suma total de iteraciones de la Reglaâ¯3.
iterar_reglas_0_y_3(Sudoku, NuevoSudoku, ContadorTotal) :-
    resolver_reglas_0_y_3(Sudoku, SudokuIntermedio, ContadorEstaPasada),
    (   Sudoku \= SudokuIntermedio
    ->  iterar_reglas_0_y_3(SudokuIntermedio, NuevoSudoku, ContadorRec),
        ContadorTotal is ContadorEstaPasada + ContadorRec
    ;   NuevoSudoku = Sudoku,
        ContadorTotal is 0
    ).

probar_reglas_0_y_3 :-
    sudoku1(Tablero),
    writeln("Sudoku inicial:"),
    imprimir_sudoku(Tablero),

    iterar_reglas_0_y_3(Tablero, NuevoTablero, ContadorTotal),
    writeln("Sudoku despues de aplicar las Reglas 0 y 3:"),
    imprimir_sudoku(NuevoTablero),

    format('Numero total de iteraciones (Regla 0 + Regla 3): ~w~n', [ContadorTotal]).

%----------------------------------------------------------
% Reglas 0, 1, 2 y 3 con contador para la Regla 3
%----------------------------------------------------------
%
% Si quieres combinar la Regla 3 con las demÃ¡s, de forma similar
% a la Regla 2, defines una versiÃ³n que aplique la Regla 3 iterativamente
% (resolver_regla_3/3) en la secuencia que desees, y en los predicados
% âiterarâ vas sumando el contador de la Regla 3.

resolver_reglas_0_y_1_y_2_y_3(Sudoku, NuevoSudoku, ContadorThisPass) :-
    % (1) Generar posibilidades
    generar_posibilidades(Sudoku, Posibilidades),
    writeln("Posibilidades iniciales:"),
    imprimir_sudoku(Posibilidades),

    % (2) Regla 3 iterativa â ContadorR3
    resolver_regla_3(Posibilidades, PosRegla3, ContadorR3),
    writeln("Posibilidades despues de aplicar la Regla 3:"),
    imprimir_sudoku(PosRegla3),

    % (3) Regla 2 iterativa â ContadorR2
    resolver_regla_2(PosRegla3, PosRegla2, ContadorR2),
    writeln("Posibilidades despues de aplicar la Regla 2:"),
    imprimir_sudoku(PosRegla2),

    % (4) Regla 1 iterativa â ContadorR1
    resolver_regla_1(PosRegla2, PosRegla1, ContadorR1),
    writeln("Posibilidades despues de aplicar la Regla 1:"),
    imprimir_sudoku(PosRegla1),

    % (5) Regla 0 iterativa en el Sudoku â ContadorR0
    resolver_regla_0(Sudoku, SudokuFinal, ContadorR0),
    writeln("Sudoku despues de aplicar la Regla 0:"),
    imprimir_sudoku(SudokuFinal),

    % (6) Devolvemos el Sudoku final y la suma de contadores
    NuevoSudoku = SudokuFinal,
    ContadorThisPass is ContadorR3 + ContadorR2 + ContadorR1 + ContadorR0.

iterar_reglas_0_y_1_y_2_y_3(Sudoku, NuevoSudoku, ContadorTotal) :-
    resolver_reglas_0_y_1_y_2_y_3(Sudoku, SudokuIntermedio, ContadorEstaPasada),
    (   Sudoku \= SudokuIntermedio
    ->  writeln("Sudoku Intermedio:"),
        imprimir_sudoku(SudokuIntermedio),
        writeln("Fin de esta iteraciÃ³n"),
        iterar_reglas_0_y_1_y_2_y_3(SudokuIntermedio, NuevoSudoku, ContadorRec),
        ContadorTotal is ContadorEstaPasada + ContadorRec
    ;   NuevoSudoku = Sudoku,
        ContadorTotal is 0
    ).
   probar_reglas_0_y_1_y_2_y_3 :-
    sudoku6(Tablero),
    writeln("Sudoku inicial:"),
    imprimir_sudoku(Tablero),

    iterar_reglas_0_y_1_y_2_y_3(Tablero, NuevoTablero, ContadorTotal),
    writeln("Sudoku despues de aplicar las Reglas 0, 1, 2 y 3:"),
    imprimir_sudoku(NuevoTablero),

    format('Numero total de iteraciones (Regla 0 + Regla 1 + Regla 2 + Regla 3): ~w~n', [ContadorTotal]),

    % (Opcional) Ver quÃ© posibilidades quedaron:
    generar_posibilidades(NuevoTablero, PosFinales),
    imprimir_sudoku(PosFinales).
% Predicado para verificar si un Sudoku estÃ¡ completo
sudoku_completo(Sudoku) :-
    \+ (member(Casilla, Sudoku), \+ number(Casilla)).

% Predicado para contar el nÃºmero de Sudokus completos e incompletos
contar_sudokus([], 0, 0).
contar_sudokus([Sudoku|Resto], Completos, Incompletos) :-
    contar_sudokus(Resto, CompletosResto, IncompletosResto),
    (   sudoku_completo(Sudoku) ->
        Completos is CompletosResto + 1,
        Incompletos is IncompletosResto
    ;   Completos is CompletosResto,
        Incompletos is IncompletosResto + 1
    ).

% Predicado para resolver la Regla 0 para una lista de Sudokus


resolver_regla_0_para_lista([], [], 0).
resolver_regla_0_para_lista([Sudoku|Resto], [SudokuResuelto|RestoResueltos], ContadorTotal) :-
    resolver_regla_0(Sudoku, SudokuResuelto, ContadorActual),
    resolver_regla_0_para_lista(Resto, RestoResueltos, ContadorResto),
    ContadorTotal is ContadorActual + ContadorResto.

%Las iteraciones aquÃ­ funcionan de manera que se llama a la regla 1, 2 o 3 y luego la regla 0 hace multiples iteraciones sobre si misma hasta que no hay cambios
resolver_regla_1_para_lista([], [], 0).
resolver_regla_1_para_lista([Sudoku|Resto], [SudokuResuelto|RestoResueltos], ContadorTotal) :-
    % Usamos la versiÃ³n con iteraciÃ³n y contador:
    iterar_reglas_0_y_1(Sudoku, SudokuResuelto, ContadorActualR1),
    resolver_regla_1_para_lista(Resto, RestoResueltos, ContadorResto),
    ContadorTotal is ContadorActualR1 + ContadorResto.

resolver_regla_2_para_lista([], [], 0).
resolver_regla_2_para_lista([Sudoku|Resto], [SudokuResuelto|RestoResueltos], ContadorTotal) :-
    % Llamamos a la iteraciÃ³n de 0 y 2 con contador:
    iterar_reglas_0_y_2(Sudoku, SudokuResuelto, ContadorActualR2),
    resolver_regla_2_para_lista(Resto, RestoResueltos, ContadorResto),
    ContadorTotal is ContadorActualR2 + ContadorResto.

resolver_regla_3_para_lista([], [], 0).
resolver_regla_3_para_lista([Sudoku|Resto], [SudokuResuelto|RestoResueltos], ContadorTotal) :-
    % Llamamos a la iteraciÃ³n de 0 y 3 con contador:
    iterar_reglas_0_y_3(Sudoku, SudokuResuelto, ContadorActualR3),
    resolver_regla_3_para_lista(Resto, RestoResueltos, ContadorResto),
    ContadorTotal is ContadorActualR3 + ContadorResto.

% Predicado para imprimir barras
imprimir_barras(0).
imprimir_barras(N) :-
    N > 0,
    write('|'),
    N1 is N - 1,
    imprimir_barras(N1).

% Predicado para imprimir el nÃºmero de Sudokus completos e incompletos con barras
imprimir_conteo_sudokus(Completos, Incompletos) :-
    format('Numero de Sudokus completos  : ~w ', [Completos]),
    imprimir_barras(Completos), nl,
    format('Numero de Sudokus incompletos: ~w ', [Incompletos]),
    imprimir_barras(Incompletos), nl.


% Predicado para probar la cuenta de Sudokus completos e incompletos
probar_contar_sudokus_regla_0 :-
    Sudokus = [sudoku, sudoku1, sudoku2, sudoku4, sudoku5, sudoku6, sudoku7, sudoku8,
               sudoku9, sudoku10, sudoku11, sudoku12, sudoku13, sudoku14, sudoku15,
               sudoku16, sudoku17, sudoku18, sudoku19, sudoku20, sudoku21, sudoku22,
               sudoku23, sudoku24, sudoku25],
    findall(S, (member(Pred, Sudokus), call(Pred, S)), ListaSudokus),
    resolver_regla_0_para_lista(ListaSudokus, ListaSudokusResueltos, ContadorTotal),
    contar_sudokus(ListaSudokusResueltos, Completos, Incompletos),
    imprimir_conteo_sudokus(Completos, Incompletos),
    writeln("Numero total de iteraciones de la Regla 0 en TODOS los Sudokus:"),
    writeln(ContadorTotal).

% Predicado para probar la cuenta de Sudokus completos e incompletos
pprobar_contar_sudokus_regla_1 :-
    Sudokus = [sudoku, sudoku1, sudoku2, sudoku4, sudoku5, sudoku6, sudoku7, sudoku8,
               sudoku9, sudoku10, sudoku11, sudoku12, sudoku13, sudoku14, sudoku15,
               sudoku16, sudoku17, sudoku18, sudoku19, sudoku20, sudoku21, sudoku22,
               sudoku23, sudoku24, sudoku25],
    findall(S, (member(Pred, Sudokus), call(Pred, S)), ListaSudokus),
    resolver_regla_1_para_lista(ListaSudokus, ListaSudokusResueltos, ContadorTotalR1),
    contar_sudokus(ListaSudokusResueltos, Completos, Incompletos),
    imprimir_conteo_sudokus(Completos, Incompletos),
    writeln("Numero total de iteraciones de la Regla 1 en TODOS los Sudokus:"),
    writeln(ContadorTotalR1).

probar_contar_sudokus_regla_2 :-
    Sudokus = [sudoku, sudoku1, sudoku2, sudoku4, sudoku5, sudoku6, sudoku7, sudoku8,
               sudoku9, sudoku10, sudoku11, sudoku12, sudoku13, sudoku14, sudoku15,
               sudoku16, sudoku17, sudoku18, sudoku19, sudoku20, sudoku21, sudoku22,
               sudoku23, sudoku24, sudoku25],
    findall(S, (member(Pred, Sudokus), call(Pred, S)), ListaSudokus),
    resolver_regla_2_para_lista(ListaSudokus, ListaSudokusResueltos, ContadorTotalR2),
    contar_sudokus(ListaSudokusResueltos, Completos, Incompletos),
    imprimir_conteo_sudokus(Completos, Incompletos),
    writeln("Numero total de iteraciones de la Regla 2 en TODOS los Sudokus:"),
    writeln(ContadorTotalR2).


probar_contar_sudokus_regla_3 :-
    Sudokus = [sudoku, sudoku1, sudoku2, sudoku4, sudoku5, sudoku6, sudoku7, sudoku8,
               sudoku9, sudoku10, sudoku11, sudoku12, sudoku13, sudoku14, sudoku15,
               sudoku16, sudoku17, sudoku18, sudoku19, sudoku20, sudoku21, sudoku22,
               sudoku23, sudoku24, sudoku25],
    findall(S, (member(Pred, Sudokus), call(Pred, S)), ListaSudokus),
    resolver_regla_3_para_lista(ListaSudokus, ListaSudokusResueltos, ContadorTotalR3),
    contar_sudokus(ListaSudokusResueltos, Completos, Incompletos),
    imprimir_conteo_sudokus(Completos, Incompletos),
    writeln("Numero total de iteraciones de la Regla 3 en TODOS los Sudokus:"),
    writeln(ContadorTotalR3).
interfaz_interactiva :-
    writeln('Ingrese el Sudoku como una lista de 81 elementos (usar . para celdas vacÃ­as):'),
    read(Sudoku),
    (   length(Sudoku, 81)
    ->  interfaz_menu(Sudoku)
    ;   writeln('Error: La lista ingresada debe tener 81 elementos.')
    ).

%==========================================
% Bucle principal de la interfaz
%==========================================
interfaz_menu(Sudoku) :-
    writeln('------------------------------'),
    writeln('Estado actual del Sudoku:'),
    imprimir_sudoku(Sudoku),
    writeln('------------------------------'),
    writeln('Seleccione la regla a aplicar:'),
    writeln('   0 - Regla 0 (actualiza celdas con posibilidad Ãºnica)'),
    writeln('   1 - Regla 1 (eliminaciÃ³n de Ãºnicos globales)'),
    writeln('   2 - Regla 2 (eliminaciÃ³n de pares Ãºnicos)'),
    writeln('   3 - Regla 3 (eliminaciÃ³n de trÃ­os Ãºnicos)'),
    writeln('   t - Terminar la resoluciÃ³n'),
    read(Opcion),
    (   Opcion == t
    ->  writeln('ResoluciÃ³n terminada.')
    ;   aplicar_regla_interactiva(Opcion, Sudoku, NuevoSudoku),
        interfaz_menu(NuevoSudoku)
    ).

%==========================================
% AplicaciÃ³n de cada regla (con contador)
%==========================================
aplicar_regla_interactiva(0, Sudoku, NuevoSudoku) :-
    writeln('Aplicando Regla 0...'),
    resolver_regla_0(Sudoku, NuevoSudoku, Contador0),
    format('Se realizaron ~w iteraciones de la Regla 0.~n', [Contador0]).

aplicar_regla_interactiva(1, Sudoku, NuevoSudoku) :-
    writeln('Aplicando Regla 1...'),
    iterar_reglas_0_y_1(Sudoku, NuevoSudoku, ContadorR1),
    format('Se realizaron ~w iteraciones de la Regla 1.~n', [ContadorR1]).

aplicar_regla_interactiva(2, Sudoku, NuevoSudoku) :-
    writeln('Aplicando Regla 2...'),
    iterar_reglas_0_y_2(Sudoku, NuevoSudoku, ContadorR2),
    format('Se realizaron ~w iteraciones de la Regla 2.~n', [ContadorR2]).

aplicar_regla_interactiva(3, Sudoku, NuevoSudoku) :-
    writeln('Aplicando Regla 3...'),
    iterar_reglas_0_y_3(Sudoku, NuevoSudoku, ContadorR3),
    format('Se realizaron ~w iteraciones de la Regla 3.~n', [ContadorR3]).

% Si la opciÃ³n no es ninguna de las anteriores, no se hace nada.
aplicar_regla_interactiva(_, Sudoku, Sudoku) :-
    writeln('OpciÃ³n no vÃ¡lida, no se aplicÃ³ ninguna regla.').
